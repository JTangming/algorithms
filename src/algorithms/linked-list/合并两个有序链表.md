### 合并两个有序链表（简单入门）

原题见 https://leetcode-cn.com/problems/merge-two-sorted-lists/

> 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例：**
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

在截图前先要搞明白其数据结构，如上示例输入的数据格式如下：
```js
// listNode
{
  val: 1,
  next: {
      val: 2,
      next: { val: 4, next: null }
    }
}
```

### 常规法
通过一个哨兵头结节点来承接两个链表中较小的节点，设置一个变量 prev 用于记录新拼接的链表的尾结点，作用是继续指向后续比较结果的节点。

比较到最后，l1、l2 链表终有一个指向空节点(null)，此时将拼接链表尾节点指向另一个链表剩下的节点即可。代码如下：
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    let headNode = new ListNode();
    let prev = headNode;
    while (l1 && l2) {
        if (l1.val <= l2.val) {
            prev.next = l1;
            l1 = l1.next;
        } else {
            prev.next = l2;
            l2 = l2.next;
        }
        prev = prev.next;
    }
    prev.next = !l1 ? l2 : l1;
    return headNode.next;
};
```
> 时间复杂度是O(m+n)，空间复杂度是常量级别的，每次只需要修改 prev 的指向，所以为 O(1)。

### 递归
由于两个链表都是有序的，所以优先比较第一个节点的 val 值，如果：
* l1.val < l2.val，则可将 l1 的指针指向 l1.next 和 l2 两个链表的最小值；
* 否则，则可将 l2 的指针指向 l2.next 和 l1 两个链表的最小值。

可以采用递归的方式不断迭代出最终答案，代码如下：
```js
var mergeTwoLists = function(l1, l2) {
    if(l1 === null){
        return l2;
    }
    if(l2 === null){
        return l1;
    }
    if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
};
```

> 时间空间复杂度都为 O(m + n)，相当于遍历两个链表迭代得出结果。