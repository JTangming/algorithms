### 最长公共子序列
原题见：https://leetcode-cn.com/problems/longest-common-subsequence/

> 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。

首先是找到递归思路，即问题拆分，分解为几个子问题的解。
如下图：
![lcs](../../../assets/dp-recursive/lcs.jpg)

结合上图来说：
- 如果 S1 与 S2 的最后一个元素相等，那么 S1 和 S2 的 LCS 就等于{S1 减去最后一个元素}与{S2 减去最后一个元素}的 LCS 加 1。
- 如果 S1 与 S2 的最后一个元素不相等，那么 S1 和 S2 的 LCS 就取{S1 减去最后一个元素}与 S2 的 LCS，{S2 减去最后一个元素}与 S1 的LCS 中的最大的那个序列。

接下来找递归出口，当 S1 或 S2 长度为 0，则 LCS 为 0。

归纳成数学公式如下：
1. i=0 或 j=0，dp[i][j] = 0
2. i,j > 0, s1[i - 1] === s2[j - 1] 则 dp[i][j] = dp[i-1][j-1] + 1;
3. i,j > 0, s1[i - 1] !== s2[j - 1] 则 dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);

最终代码如下：
```js
/**
 * @param {string} text1
 * @param {string} text2
 * @return {number}
 */
var longestCommonSubsequence = function(text1, text2) {
    var t1_len = text1.length;
    var t2_len = text2.length;
    // var dp = new Array(t1_len+1);

    // for (var k = 0; k < t1_len + 1; k++) {
    //     dp[k] = new Array(t2_len+1);
    // }
    // dp[0][0] = 0;
    var dp = new Array(t1_len+1).fill(0);
    for(var k = 0;k <= t1_len; k++){
        dp[k] = new Array(t2_len+1).fill(0);
    }
    for (var i = 1; i <= t1_len; i++) {
        for (var j = 1; j <= t2_len; j++) {
            // 问题拆分
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }

    return dp[t1_len][t2_len];
};
```