### 雨水收集

> 原题见：https://leetcode-cn.com/problems/trapping-rain-water/

![trapping-rain-water](./../../..//assets/algorithm/uncategorized/trapping-rain-water.jpg)

#### 暴力法
首先我不排斥暴力法，至少说明理解了题意并且有解决办法。

如图，如需要获取第 i 个柱子能装下的雨水，需要在其左右都有比它高的柱子，即其左边最高的柱子和其右边最高的柱子围起来建立的“水池”高度 - 自身高度，则为该柱子能获取到的雨水量。

暴力法即根据题意去写代码，如下：
```JS
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let len = height.length;
    let ans = 0;
    for (let i = 0; i < len; i++) {
        let lMax = 0, rMax = 0;
        // 通过变量记录其左边的最高柱子
        for (let m = i; m >= 0; m--) {
            lMax = Math.max(lMax, height[m]);
        }
        // 通过变量记录其右边的最高柱子
        for (let k = i; k < len; k++) {
            rMax = Math.max(rMax, height[k]);
        }
        ans += Math.min(lMax, rMax) - height[i];
    }

    return ans;
};
```
> 时间复杂度为 O(n^2)，空间复杂度为 O(1)

### 动态规划
根据以往 dp 经验，可以把 i 左右最大高度柱子暂存起来以供遍历使用。

从左至右遍历 i 左边最大的高度方程为：lMax[i] = Math.max(lMax[i-1], height[i])

从右到左遍历 i 右边最大的高度方程为：rMax[i] = Math.max(rMax[i+1], height[i])

那么迭代方程式可以是所有 `dp[]min(max_left[i], max_right[i]) − height[i]` 的和。

代码就好写了，如下：
```JS
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    let len = height.length;
    let ans = 0;
    let lMax = new Array(len);
    let rMax = new Array(len);
    lMax[0] = height[0];
    rMax[len-1] = height[len-1];
    for (let i = 1; i < len; i++) {
        lMax[i] = Math.max(lMax[i-1], height[i]);
    }
    for (let i = len - 2; i >= 0; i--) {
        rMax[i] = Math.max(rMax[i+1], height[i]);
    }
    for (let i = 0; i < len; i++) {
        ans += Math.min(lMax[i], rMax[i]) - height[i];
    }

    return ans;
};
```
> 时间\空间复杂度为 O(n)

### 使用双指针
// todo
