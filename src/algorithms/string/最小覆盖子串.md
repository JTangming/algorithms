### 最小覆盖子串

原题：https://leetcode-cn.com/problems/minimum-window-substring/

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

示例：
```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

#### 滑动窗口

滑动窗口算法的思路是这样的（针对字符串相关题型(s, t)，s 为被参照字符串，t 为目标字符串）：

① 对于被参照字符串，初始化 left、right 为 0，先不断增加 right 直到窗口中（left -> right）的字符串满足包含了目标字符串所有字符

② 基于上一 right，可以增加 left 以缩小窗口，直到窗口中（left -> right）的字符串满足不再包含目标字符串所有字符

不断重复①②，直到 right 到达 s 的最后一个字符，滑动窗口一般要维护一个长度变量，用于记录最优解的起始位置和终止位置。

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function(s, t) {
    let need = new Map();
    for (let i = 0; i < t.length; i++) {
        need.set(t[i], (need.get(t[i]) || 0) + 1);
    }
    
    let left = 0, right = 0;
    let valid = 0;
    let windowMap = new Map(); 
    let start = 0;
    let len = Infinity
    while (right < s.length) {
        let char = s[right];
        right++;
        // 记录 t 中字符在滑动窗口出现的次数
        if (need.get(char)) {
            windowMap.set(char, (windowMap.get(char) || 0) + 1);

            if (windowMap.get(char) === need.get(char)) {
                valid++;
            }
        }

        while (valid === need.size) {
            let lChar = s[left];
            if (need.get(lChar)) {
                windowMap.set(lChar, windowMap.get(lChar) - 1);
                
                if (windowMap.get(lChar) < need.get(lChar)) {
                    valid--;
                }
            }

            if (right - left < len) {
                start = left;
                len = right - left;
            }
            

            left++;
        }
    }

    return len === Infinity ? '' : s.substr(start, len);
};
```

时间复杂度为 O(N)