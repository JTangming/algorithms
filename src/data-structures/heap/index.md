### 堆（Heap）

堆（Heap）是一个可以被看成近似完全二叉树的数组，树上的每一个结点对应数组的一个元素。除了最底层外，该树是完全充满的，而且是从左到右填充。—— 来自：《算法导论》

满足二叉堆的要求：
- 二叉堆必须是完全二叉树；
- 二叉堆中的每一个节点，都必须大于等于（或小于等于）其子树中每个节点的值。

堆包括最大堆和最小堆：
- 最大堆的每一个节点（除了根结点）的值不大于其父节点；
- 最小堆的每一个节点（除了根结点）的值不小于其父节点。

树上的每一个结点对应数组的一个元素，为什么我们可以用数组来存储堆呢？

![heap-1](./../../../assets/data-structrue/heap/heap-1.jpg)
<center>https://pic.leetcode-cn.com/1615870575-Ubyzzb-file_1615870575038</center>

先看根节点，也就是值为 1 的节点，它在数组中的下标为 1，它的左子节点，也就是值为 4 的节点，此时索引为 2，右子节点也就是值为 2 的节点，它的索引为 3。

由此找到其中的对应关系：

数组中，某节点（非叶子节点）的下标为 i，那么其左子节点下标为 2*i （这里可以直接通过相乘得到左孩子，如果从 0 开始存，需要 2i+1 才行）, 右子节点为 2i+1。孩子节点的父节点为 Math.floor(i/2)。既然我们完全可以根据索引找到某节点的左右子节点，那么用数组存储是完全没有问题的。

堆常见的操作：

- HEAPIFY 建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为 O(n)；
- HEAPPUSH：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为 O(log n)；
- HEAPPOP：从最大堆中取出最大值或从最小堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度为 O(log n)；
- HEAPSORT：借由 HEAPIFY 建堆和 HEAPPOP 堆数组进行排序，时间复杂度为 O(nlog n)，空间复杂度为 O(1).

堆结构的一个常见应用是建立优先队列（Priority Queue）。